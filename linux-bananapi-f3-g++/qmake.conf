# =============================================================================
# qmake Configuration File - RISC-V64 with Vector Extension 1.0
# Cross-Compilation Environment for Banana Pi F3 (Armbian OS)
# =============================================================================
#
# This file defines compiler settings, linker settings, library paths, etc.
# when building Qt applications using qmake.
# It includes optimization settings to leverage the RISC-V64 architecture's
# vector extension instruction set (RVV 1.0).
#
# The qmake.conf file aggregates platform-specific settings for Qt and
# is placed in the mkspecs directory.
# Example: $QTDIR/mkspecs/linux-riscv64-gnu-g++/qmake.conf

# =============================================================================
# Include Common Device Settings
# =============================================================================
# Load the common settings for standard Linux devices provided by Qt.
# These settings include basic path configurations and compiler variable
# initialization necessary for cross-compilation environments.
#
# linux_device_pre.conf includes settings such as:
# - Basic compiler configuration (gcc/g++ specification)
# - System root path (SYSROOT) reference method
# - Basic flags for cross-compilation
include(../common/linux_device_pre.conf)

# =============================================================================
# Default QPA (Qt Platform Abstraction) Platform Setting
# =============================================================================
# QPA is an abstraction layer for porting Qt's GUI functionality to different
# window systems and display servers.
#
# If the following line is commented out, the default will be eglfs
# (framebuffer direct drawing) or xcb (X11).
# To use a Wayland compositor, uncomment the following line:
#
# QT_QPA_DEFAULT_PLATFORM = wayland
#
# Main QPA platforms:
# - wayland    : For Wayland display server (modern Linux desktop)
# - xcb        : For X11 window system (traditional Linux desktop)
# - eglfs      : Framebuffer direct drawing for embedded systems (no X/Wayland)
# - linuxfb    : For Linux framebuffer (legacy, no EGL)
#QT_QPA_DEFAULT_PLATFORM = wayland

# =============================================================================
# System Root (Sysroot) Path Definition
# =============================================================================
# $$[QT_SYSROOT] refers to the root filesystem of the target device specified
# when running the CMake toolchain file or Qt Configurator.
# By using this variable, you can flexibly reference the locations of header
# files and libraries.
#
# Example: If -sysroot /path/to/rootfs is specified during configure,
#          $$[QT_SYSROOT] expands to /path/to/rootfs

# Reference to the include directory within the system root
# Standard header files (under /usr/include) are searched from here
SYSROOT_INC = $$[QT_SYSROOT]/usr/include

# Reference to the library directory within the system root
# Standard library files (under /usr/lib) are searched from here
SYSROOT_LIB = $$[QT_SYSROOT]/usr/lib

# =============================================================================
# OpenGL ES / EGL Related Include and Library Path Settings
# =============================================================================
# When using Qt's 3D drawing features (Qt Quick, Qt 3D, etc.), you need to
# specify the location of graphics libraries.
#
# On RISC-V64 systems, OpenGL ES (Embedded Systems) for embedded systems is
# commonly used rather than desktop OpenGL.
# The Banana Pi F3's GPU (Imagination PowerVR) also supports OpenGL ES 3.2.

# EGL (Embedded-System Graphics Library) include directory
# EGL is an interface that connects OpenGL ES to native window systems
# (such as framebuffers). It handles surface management and context creation.
QMAKE_INCDIR_EGL        = $$[SYSROOT_INC] \
                          $$[SYSROOT_INC]/riscv64-linux-gnu \
                          $$[SYSROOT_INC]/GL \
                          $$[SYSROOT_INC]/EGL \
                          $$[SYSROOT_INC]/GLES \
                          $$[SYSROOT_INC]/GLES2 \
                          $$[SYSROOT_INC]/GLES3 \
                          $$[SYSROOT_INC]/GLFW

# EGL library directory
# riscv64-linux-gnu is the multiarch-compliant library path in Debian-based
# systems. It allows different architecture libraries to coexist.
QMAKE_LIBDIR_EGL        = $$[SYSROOT_LIB] \
                          $$[SYSROOT_LIB]/riscv64-linux-gnu

# OpenGL ES 2.0 paths reference the same location as EGL
# OpenGL ES 2.0 provides a shader-based programmable pipeline
# It is the most widely supported version on mobile and SBCs
QMAKE_INCDIR_OPENGL_ES2 = $$[QMAKE_INCDIR_EGL]
QMAKE_LIBDIR_OPENGL_ES2 = $${QMAKE_LIBDIR_EGL}

# OpenVG (Open Vector Graphics) paths also reference the same location as EGL
# OpenVG is an API that provides hardware acceleration for 2D vector graphics,
# but its usage has decreased in modern systems
QMAKE_INCDIR_OPENVG     = $${QMAKE_INCDIR_EGL}
QMAKE_LIBDIR_OPENVG     = $${QMAKE_LIBDIR_EGL}

# =============================================================================
# Graphics Library Link Settings
# =============================================================================
# Specify libraries that qmake automatically adds during linking.
# These libraries are necessary when using Qt's GUI features.

# Link EGL library
# -lEGL means passing libEGL.so to the linker
QMAKE_LIBS_EGL          = -lEGL

# Link OpenGL ES 2.0 library
# When using GLESv2, EGL is also needed underneath, so link both
QMAKE_LIBS_OPENGL_ES2   = -lGLESv2 $${QMAKE_LIBS_EGL}

# Link OpenVG library (low usage frequency)
QMAKE_LIBS_OPENVG       = -lOpenVG $${QMAKE_LIBS_EGL}

# =============================================================================
# RISC-V64 Vector Extension 1.0 Compiler Flags
# =============================================================================
# This is the most important setting. By enabling RISC-V64 vector extensions,
# high-performance code utilizing SIMD vector operations is generated.
#
# [Architecture Specification Details]
# -march=rv64gcv components:
#
#   rv64    : 64-bit RISC-V base integer instruction set
#
#   g       : Shorthand for general-purpose extensions. Combines these 5 extensions:
#     I     : Base integer instruction set (addition, subtraction, logical operations, etc.)
#     M     : Multiplication/division instructions (mul, div, rem, etc.)
#     A     : Atomic instructions (essential for multithreading/multicore synchronization)
#     F     : Single precision (32-bit) floating point instructions
#     D     : Double precision (64-bit) floating point instructions
#
#   c       : Compressed instruction extension
#             Enables use of shortened 16-bit length instructions
#             Reduces code size by 25-30% and improves instruction cache efficiency
#
#   v       : Vector extension 1.0 (RVV 1.0) ★IMPORTANT★
#             This extension enables vector operations
#             Provides SIMD functionality to execute operations on multiple data simultaneously
#             Significant performance improvements expected in image processing, audio processing,
#             scientific computing, etc.
#
# [ABI Specification Details]
# -mabi=lp64d meaning:
#   lp64    : Long and Pointer are 64-bit (Int is 32-bit)
#   d       : ABI that passes double precision floating point numbers in floating point registers
#
# Vector extension registers are used in addition to the existing ABI,
# so no special ABI specification for vectors (e.g., lp64v) is needed.
# Vector registers become automatically available.
#
# [Additional Information]
# If you want to specify a particular vector length (usually not needed):
#   -march=rv64gcv1p0         : Explicitly specify vector extension version 1.0
#   -march=rv64gcv_zvl256b    : Specify minimum vector length as 256 bits
#
# The Banana Pi F3's Spacemit X60 processor supports variable-length vectors,
# with vector length determined at runtime (VLEN is implementation-dependent).
COMPILER_FLAGS          = -march=rv64gcv -mabi=lp64d

# Apply to C compiler flags
# Automatic vectorization will be performed for C code as well
QMAKE_CFLAGS            = $${COMPILER_FLAGS}

# Apply to C++ compiler flags
# Automatic vectorization will be performed for C++ code as well
# STL algorithms (std::transform, std::for_each, etc.) may also be vectorized
QMAKE_CXXFLAGS          = $${COMPILER_FLAGS}

# Optimization flags for release builds
# -O2              : Balanced optimization level
#                    Good balance of compilation time, code size, and execution speed
# -ftree-vectorize : Explicitly enable loop vectorization
#                    Usually automatically enabled with -O2, but explicitly ensures vectorization
#                    Important flag for leveraging vector extensions
# -pipe            : Connect processes with pipes instead of writing intermediate files to disk
#                    Reduces build time (less disk I/O)
QMAKE_CXXFLAGS_RELEASE += -O2 -ftree-vectorize -pipe

# =============================================================================
# [Further Optimization Options]
# =============================================================================
# If higher performance is needed, consider the following flags:
#
# QMAKE_CXXFLAGS_RELEASE += -O3 -ftree-vectorize -fno-vect-cost-model -pipe
#
# -O3                  : Maximum optimization
#                        Aggressive function inlining, loop unrolling, etc.
#                        Code size increases and compilation time lengthens, but
#                        execution speed may improve
#
# -fno-vect-cost-model : Disable vectorization cost calculation
#                        Compiler doesn't estimate vectorization effectiveness and
#                        tries to vectorize all possible loops
#                        May be counterproductive in some cases, so
#                        recommend taking benchmarks for verification
#
# -funroll-loops       : Force loop unrolling
#                        Reduces loop overhead but significantly increases code size
#
# -ffast-math          : Aggressively optimize floating point operations
#                        Performs optimizations that deviate from strict IEEE 754 specifications
#                        Precision may slightly decrease, so caution needed for
#                        applications where precision is critical (scientific computing, etc.)
#
# [Verifying Vectorization]
# Adding the following flags during compilation outputs detailed vectorization information:
#   -fopt-info-vec-optimized : Information on vectorized loops
#   -fopt-info-vec-missed    : Information on loops that couldn't be vectorized and reasons
#   -fopt-info-vec-all       : All vectorization information (detailed)
#
# Example: QMAKE_CXXFLAGS_RELEASE += -O2 -ftree-vectorize -fopt-info-vec-optimized

# =============================================================================
# Linker Library Specification
# =============================================================================
# Specify standard system libraries used by Qt applications.
# These libraries are necessary for most Linux applications.
#
# -lrt        : POSIX.1b real-time extension library
#               Provides clock_gettime() and timer-related functions
#               Used by Qt's QElapsedTimer, etc.
#
# -lpthread   : POSIX thread library
#               Provides multithreading functionality
#               Used by Qt's QThread and QtConcurrent
#
# -ldl        : Dynamic link library
#               Provides dlopen(), dlsym(), etc.
#               Used by plugin systems
QMAKE_LIBS              += -lrt -lpthread -ldl

# =============================================================================
# Distribution-Specific Options
# =============================================================================
# Flags to convey target system characteristics to Qt's configure script
# and build system.

# Explicitly specify RISC-V64 architecture
# This ensures proper handling of architecture-specific code and library paths
DISTRO_OPTS += riscv64

# Multiarch support for Debian-based distributions (including Armbian)
# Multiarch is a mechanism to coexist libraries of multiple architectures
# on the same system.
# Example: Paths in the form /usr/lib/riscv64-linux-gnu/ are used
#
# Armbian is a Debian-based Linux distribution for embedded boards,
# providing official support for Banana Pi F3
DISTRO_OPTS += deb-multi-arch

# =============================================================================
# EGLFS (EGL Full Screen) Device Integration Settings
# =============================================================================
# EGLFS is Qt's platform plugin for drawing directly to the framebuffer
# without X11 or Wayland. Widely used in embedded systems.
#
# KMS (Kernel Mode Setting) backend:
# Uses DRM/KMS kernel subsystem for display resolution settings and
# buffer swapping. Standard of modern Linux graphics stack.
#
# Other options:
# - eglfs_kms_egldevice : Uses NVIDIA's EGLDevice extension (for embedded Nvidia GPUs)
# - eglfs_kms_vsp2      : For Renesas VSP2 hardware compositor
# - eglfs_mali          : For ARM Mali GPU (legacy)
# - eglfs_brcm          : For Broadcom VideoCore GPU (Raspberry Pi)
#
# For Banana Pi F3's Imagination PowerVR GPU, eglfs_kms is the appropriate choice
EGLFS_DEVICE_INTEGRATION = eglfs_kms

# =============================================================================
# Include Common Device Settings Post-Processing
# =============================================================================
# Load the post-processing portion of common settings for Linux devices provided by Qt.
# Based on variables set up to this point, final compiler and linker flags are determined.
#
# Note: In the original file, linux_arm_device_post.conf is commented out and
#       linux_device_post.conf is used instead.
#       This is because RISC-V64 is not an ARM architecture,
#       so more generic device settings are used.
#
#include(../common/linux_arm_device_post.conf)
include(../common/linux_device_post.conf)

# =============================================================================
# Load Qt Configuration
# =============================================================================
# Load Qt's own configuration (enabled features, modules, paths, etc.).
# This references the qt_config.pri file generated when Qt's configure script was executed.
load(qt_config)

# =============================================================================
# End of Configuration File
# =============================================================================
#
# [How to Use This File]
#
# 1. Build Qt cross-compilation environment:
#    ./configure -prefix /opt/qt6-riscv64 \
#                -device linux-riscv64-gnu-g++ \
#                -sysroot /path/to/sysroot \
#                -device-option CROSS_COMPILE=/path/to/riscv64-linux-gnu- \
#                ...
#
# 2. Place this qmake.conf file at:
#    $QTDIR/mkspecs/linux-riscv64-gnu-g++/qmake.conf
#
# 3. Build project using qmake:
#    qmake your_project.pro
#    make
#
# [How to Verify Vector Extension Effects]
#
# 1. Check if vector instructions are generated:
#    riscv64-linux-gnu-objdump -d your_binary | grep -E "vl|vs|vadd|vmul"
#    (vl=vector load, vs=vector store, vadd/vmul=vector arithmetic instructions)
#
# 2. Performance testing:
#    Build the same program with and without vector extensions
#    (-march=rv64gc vs -march=rv64gcv) and compare execution times
#    Significant differences appear in image processing, DSP processing, etc.
#
# 3. Compiler vectorization report:
#    Use -fopt-info-vec-* flags explained above to check which loops were vectorized
#
# [Troubleshooting]
#
# Q: Build error "unknown architecture 'rv64gcv'"
# A: GCC version may be old. Use GCC 12 or later
#
# Q: Vector instructions are not generated
# A: Check the following:
#    - Is the loop in simple form (complex control flow doesn't vectorize)
#    - Are data dependencies preventing vectorization
#    - Check reason with -fopt-info-vec-missed
#
# Q: Performance doesn't improve or degrades
# A: Possible causes:
#    - Data size not reaching effective size for vectorization (small loops, etc.)
#    - Memory access patterns unsuitable for vectorization
#    - Vector unit latency may be higher than scalar operations in some cases
